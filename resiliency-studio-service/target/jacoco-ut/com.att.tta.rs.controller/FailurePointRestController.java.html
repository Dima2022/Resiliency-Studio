<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FailurePointRestController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">resiliency-studio-service</a> &gt; <a href="index.source.html" class="el_package">com.att.tta.rs.controller</a> &gt; <span class="el_source">FailurePointRestController.java</span></div><h1>FailurePointRestController.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 *   BSD License
 *    
 *   Copyright (c) 2017, AT&amp;T Intellectual Property.  All other rights reserved.
 *    
 *   Redistribution and use in source and binary forms, with or without modification, are permitted
 *   provided that the following conditions are met:
 *    
 *   1. Redistributions of source code must retain the above copyright notice, this list of conditions
 *      and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice, this list of
 *      conditions and the following disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *   3. All advertising materials mentioning features or use of this software must display the
 *      following acknowledgement:  This product includes software developed by the AT&amp;T.
 *   4. Neither the name of AT&amp;T nor the names of its contributors may be used to endorse or
 *      promote products derived from this software without specific prior written permission.
 *    
 *   THIS SOFTWARE IS PROVIDED BY AT&amp;T INTELLECTUAL PROPERTY ''AS IS'' AND ANY EXPRESS OR
 *   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 *   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 *   SHALL AT&amp;T INTELLECTUAL PROPERTY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE, DATA, OR PROFITS;
 *   OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 *   DAMAGE.
 *******************************************************************************/
package com.att.tta.rs.controller;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.util.UriComponentsBuilder;

import com.att.tta.rs.model.FailurePoint;
import com.att.tta.rs.model.FailurePointAdapter;
import com.att.tta.rs.service.FailurePointService;
import com.att.tta.rs.service.MonkeyStrategyService;
import com.att.tta.rs.service.TeamUserService;
import com.att.tta.rs.util.MessageWrapper;
import com.google.common.collect.Lists;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;

/**
 * This Class provides certain REST APIs to perform CRUD operations on
 * FailurePoint repository.
 * 
 * @author mb6872,ak983d
 *
 */
@RestController
@Api(value = &quot;FailurePoint Rest Controller&quot;, description = &quot;This REST controller provides REST APIs for performing CRUD Operation on FailurePoint Repository&quot;)
<span class="fc" id="L70">public class FailurePointRestController {</span>
<span class="fc" id="L71">	private static final Logger logger = LoggerFactory.getLogger(FailurePointRestController.class);</span>

	@Autowired
	FailurePointService failurePointService;

	@Autowired
	TeamUserService userDetailsService;

	@Autowired
	MonkeyStrategyService monkeyStrategyService;

	/**
	 * This API returns list of all FailurePoint objects available in
	 * FailurePoint Repository.
	 * 
	 * @return
	 */
	@ApiOperation(value = &quot;This API returns all FailurePoint Objects present in Elastic Search&quot;, response = ResponseEntity.class)
	@ApiResponses(value = { @ApiResponse(code = 200, message = &quot;Returned all FailurePoint Objects&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to view requested object&quot;),
			@ApiResponse(code = 404, message = &quot;No FailurePoint object found&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/&quot;, method = RequestMethod.GET, produces = &quot;application/json&quot;)
	public ResponseEntity&lt;Object&gt; listAllFailurePoints() {
<span class="fc" id="L94">		List&lt;FailurePoint&gt; failurePoints = Lists.newArrayList(failurePointService.findAll());</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">		if (failurePoints.isEmpty()) {</span>
<span class="fc" id="L96">			final String error = &quot; No FailurePoint(s) found !!!&quot;;</span>
<span class="fc" id="L97">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.NOT_FOUND, error, error);</span>
<span class="fc" id="L98">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}
<span class="fc" id="L100">		return new ResponseEntity&lt;&gt;(failurePoints, HttpStatus.OK);</span>
	}

	/**
	 * This API returns FailurePoint object by given Id
	 * 
	 * @param id
	 * @return
	 */
	@ApiOperation(value = &quot;This API returns single FailurePoint Objects present in Elastic Search for given FailurePoint ID&quot;, response = ResponseEntity.class)
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = &quot;Returned single FailurePoint Object for given FailurePoint ID&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to view requested object&quot;),
			@ApiResponse(code = 404, message = &quot;No FailurePoint object found for given FailurePoint ID&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/{id}&quot;, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity&lt;Object&gt; getFailurePoint(@PathVariable(&quot;id&quot;) String id) {
<span class="fc" id="L116">		FailurePoint failurePoint = failurePointService.findOne(id);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">		if (failurePoint == null) {</span>
<span class="fc" id="L118">			final String error = &quot;FailurePoint Not found for id &quot; + id;</span>
<span class="fc" id="L119">			logger.debug(error);</span>
<span class="fc" id="L120">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.NOT_FOUND, error, error);</span>
<span class="fc" id="L121">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}
<span class="fc" id="L123">		return new ResponseEntity&lt;&gt;(failurePoint, HttpStatus.OK);</span>
	}

	/**
	 * This API returns FailurePoint object by given Name
	 * 
	 * @param name
	 * @return
	 */
	@ApiOperation(value = &quot;This API returns single FailurePoint Object present in Elastic Search for given FailurePoint Name&quot;, response = ResponseEntity.class)
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = &quot;Returned FailurePoint Object for given FailurePoint Name&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to view requested object&quot;),
			@ApiResponse(code = 404, message = &quot;No FailurePoint object found for given FailurePoint Name&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/name/{name}&quot;, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity&lt;Object&gt; getFailurePointsByName(@PathVariable(&quot;name&quot;) String name) {
<span class="fc" id="L139">		FailurePoint failurePoint = failurePointService.findByName(name);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">		if (failurePoint == null) {</span>
<span class="fc" id="L141">			final String error = &quot; FailurePoint Not found for name &quot; + name;</span>
<span class="fc" id="L142">			logger.debug(error);</span>
<span class="fc" id="L143">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.NOT_FOUND, error, error);</span>
<span class="fc" id="L144">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}
<span class="fc" id="L146">		return new ResponseEntity&lt;&gt;(failurePoint, HttpStatus.OK);</span>
	}

	/**
	 * This API returns all FailurePoints by given Category.
	 * 
	 * @param category
	 * @return
	 */
	@ApiOperation(value = &quot;This API returns FailurePoint Objects present in Elastic Search for given FailurePoint Category&quot;, response = ResponseEntity.class)
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = &quot;Returned FailurePoint Objects for given FailurePoint Category&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to view requested object&quot;),
			@ApiResponse(code = 404, message = &quot;No FailurePoint object found for given FailurePoint Category&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/category/{category}&quot;, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity&lt;Object&gt; getFailurePointByCategory(@PathVariable(&quot;category&quot;) String category) {
<span class="fc" id="L162">		List&lt;FailurePoint&gt; failurePoints = Lists.newArrayList(failurePointService.findByCategory(category));</span>
<span class="pc bpc" id="L163" title="1 of 4 branches missed.">		if (failurePoints == null || failurePoints.isEmpty()) {</span>
<span class="fc" id="L164">			final String error = &quot;failurePoints not found with category &quot; + category;</span>
<span class="fc" id="L165">			logger.debug(error);</span>
<span class="fc" id="L166">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.NOT_FOUND, error, error);</span>
<span class="fc" id="L167">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}
<span class="fc" id="L169">		return new ResponseEntity&lt;&gt;(failurePoints, HttpStatus.OK);</span>
	}

	/**
	 * This API returns all FailurePoints by Role
	 * 
	 * @param role
	 * @return
	 */
	@ApiOperation(value = &quot;This API returns FailurePoint Objects present in Elastic Search for given FailurePoint role&quot;, response = ResponseEntity.class)
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = &quot;Returned FailurePoint Objects for given FailurePoint role&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to view requested object&quot;),
			@ApiResponse(code = 404, message = &quot;No FailurePoint object found for given FailurePoint role&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/role/{role}&quot;, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
	public ResponseEntity&lt;Object&gt; getFailurePointByRole(@PathVariable(&quot;role&quot;) String role) {
<span class="fc" id="L185">		List&lt;FailurePoint&gt; failurePoints = Lists.newArrayList(failurePointService.findByRole(role));</span>
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">		if (failurePoints == null || failurePoints.isEmpty()) {</span>
<span class="fc" id="L187">			final String error = &quot;failurePoints not found for  role &quot; + role;</span>
<span class="fc" id="L188">			logger.debug(error);</span>
<span class="fc" id="L189">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.NOT_FOUND, error, error);</span>
<span class="fc" id="L190">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}
<span class="fc" id="L192">		return new ResponseEntity&lt;&gt;(failurePoints, HttpStatus.OK);</span>
	}

	/**
	 * This API creates a FailurePoint.
	 * 
	 * @param failurePoint
	 * @param ucBuilder
	 * @return
	 */
	@ApiOperation(value = &quot;This API inserts a FailurePoint Object into Elastic Search&quot;, response = ResponseEntity.class)
	@ApiResponses(value = { @ApiResponse(code = 201, message = &quot;FailurePoint object successfully inserted into ES&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to perform Add operation&quot;),
			@ApiResponse(code = 409, message = &quot;FailurePoint with same name is already exist&quot;),
			@ApiResponse(code = 404, message = &quot;The resource trying to reach is not found&quot;),
			@ApiResponse(code = 400, message = &quot;Input Request object is not valid&quot;) })
	@RequestMapping(value = &quot;/api/failurepoint/&quot;, method = RequestMethod.POST, produces = &quot;application/json&quot;)
	public ResponseEntity&lt;Object&gt; addFailurePoint(@RequestBody FailurePoint failurePoint,
			UriComponentsBuilder ucBuilder) {
<span class="fc" id="L211">		logger.debug(&quot;Creating a failurePoint with name:&quot; + failurePoint.getName());</span>

<span class="pc bpc" id="L213" title="1 of 4 branches missed.">		if (failurePoint.getName() == null || &quot;&quot;.equals(failurePoint.getName().trim())) {</span>
<span class="fc" id="L214">			final String error = &quot;FailurePoint name cannot be empty&quot;;</span>
<span class="fc" id="L215">			logger.debug(error);</span>
<span class="fc" id="L216">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.BAD_REQUEST, error, error);</span>
<span class="fc" id="L217">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}

<span class="fc bfc" id="L220" title="All 2 branches covered.">		if (failurePointService.insert(failurePoint) == null) {</span>
<span class="fc" id="L221">			final String error = &quot;FailurePoint already exist with name &quot; + failurePoint.getName();</span>
<span class="fc" id="L222">			logger.debug(error);</span>
<span class="fc" id="L223">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.CONFLICT, error, error);</span>
<span class="fc" id="L224">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}

<span class="fc" id="L227">		logger.debug(&quot;failurePoint saved in ES with id --&gt;&quot; + failurePoint.getId());</span>
<span class="fc" id="L228">		HttpHeaders headers = new HttpHeaders();</span>
<span class="fc" id="L229">		headers.setLocation(ucBuilder.path(&quot;/failurePoint/{id}&quot;).buildAndExpand(failurePoint.getId()).toUri());</span>
<span class="fc" id="L230">		return new ResponseEntity&lt;&gt;(headers, HttpStatus.CREATED);</span>
	}

	/**
	 * This API does bulk FailurePoint insertion.
	 * 
	 * @param failurePointadapter
	 * @param ucBuilder
	 * @return
	 */
	@ApiOperation(value = &quot;This API do bulk insertion of an FailurePoint Objects into Elastic Search&quot;, response = ResponseEntity.class)
	@ApiResponses(value = { @ApiResponse(code = 201, message = &quot;FailurePoint objects successfully inserted into ES&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to perform Add operation&quot;),
			@ApiResponse(code = 409, message = &quot;FailurePoint with same name is already exist&quot;),
			@ApiResponse(code = 404, message = &quot;The resource trying to reach is not found&quot;),
			@ApiResponse(code = 400, message = &quot;Input Request object is not valid&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/&quot;, method = RequestMethod.POST, produces = &quot;application/json&quot;)
	public ResponseEntity&lt;Object&gt; bulkaddFailurePoint(@RequestBody FailurePointAdapter failurePointadapter) {

<span class="fc bfc" id="L249" title="All 2 branches covered.">		if (failurePointadapter == null) {</span>
<span class="fc" id="L250">			final String error = &quot;NULL request received to add failurePoint&quot;;</span>
<span class="fc" id="L251">			logger.debug(error);</span>
<span class="fc" id="L252">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.BAD_REQUEST, error, error);</span>
<span class="fc" id="L253">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}
<span class="fc" id="L255">		logger.debug(&quot;bulk inserting failurePoints: %s&quot;, failurePointadapter.getFailurePoints().size());</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">		for (FailurePoint failurePoint : failurePointadapter.getFailurePoints()) {</span>
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">			if (failurePoint.getName() == null || &quot;&quot;.equals(failurePoint.getName().trim())) {</span>
<span class="fc" id="L259">				final String error = &quot;FailurePoint name cannot be empty&quot;;</span>
<span class="fc" id="L260">				logger.debug(error);</span>
<span class="fc" id="L261">				final MessageWrapper apiError = new MessageWrapper(HttpStatus.BAD_REQUEST, error, error);</span>
<span class="fc" id="L262">				return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
			}

<span class="fc bfc" id="L265" title="All 2 branches covered.">			if (failurePointService.insert(failurePoint) == null) {</span>
<span class="fc" id="L266">				final String error = &quot;FailurePoint with name &quot; + failurePoint.getName() + &quot; already exist&quot;;</span>
<span class="fc" id="L267">				logger.debug(error);</span>
<span class="fc" id="L268">				final MessageWrapper apiError = new MessageWrapper(HttpStatus.CONFLICT, error, error);</span>
<span class="fc" id="L269">				return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
			}

<span class="fc" id="L272">			logger.debug(&quot;failurePoint saved in ES with id: &quot; + failurePoint.getId());</span>
<span class="fc" id="L273">		}</span>
<span class="fc" id="L274">		HttpHeaders headers = new HttpHeaders();</span>
<span class="fc" id="L275">		return new ResponseEntity&lt;&gt;(headers, HttpStatus.CREATED);</span>
	}

	/**
	 * This API updates a FailurePoint
	 * 
	 * @param id
	 * @param toModifyFailurePoint
	 * @return
	 */
	@ApiOperation(value = &quot;This API updates a FailurePoint Objects into Elastic Search for given FailurePoint ID&quot;, response = ResponseEntity.class)
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = &quot;FailurePoint objects successfully updated into ES for given FailurePoint ID&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to perform Update operation &quot;),
			@ApiResponse(code = 404, message = &quot;FailurePoint object not found in ES for given FailurePoint ID&quot;),
			@ApiResponse(code = 400, message = &quot;Input Request object is not valid&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/{id}&quot;, method = RequestMethod.PUT, produces = &quot;application/json&quot;)
	public ResponseEntity&lt;Object&gt; updateFailurePoint(@PathVariable(&quot;id&quot;) String id,
			@RequestBody FailurePoint toModifyFailurePoint) {
<span class="fc" id="L294">		logger.debug(&quot;Updating FailurePoint : %s &quot;, id);</span>
<span class="fc" id="L295">		FailurePoint currentFailurePoint = failurePointService.findOne(id);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">		if (currentFailurePoint == null) {</span>
<span class="fc" id="L297">			final String error = &quot;FailurePoint with id &quot; + id + &quot; not found&quot;;</span>
<span class="fc" id="L298">			logger.debug(error);</span>
<span class="fc" id="L299">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.NOT_FOUND, error, error);</span>
<span class="fc" id="L300">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}
<span class="fc" id="L302">		toModifyFailurePoint.setId(id);</span>
<span class="fc" id="L303">		failurePointService.update(toModifyFailurePoint);</span>
<span class="fc" id="L304">		return new ResponseEntity&lt;&gt;(toModifyFailurePoint, HttpStatus.OK);</span>
	}

	/**
	 * This API deletes a FailurePoint
	 * 
	 * @param id
	 * @return
	 */
	@ApiOperation(value = &quot;This API deletes a FailurePoint Objects from Elastic Search for given FailurePoint ID&quot;, response = ResponseEntity.class)
	@ApiResponses(value = {
			@ApiResponse(code = 200, message = &quot;FailurePoint object successfully deleted from ES for given FailurePoint ID&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to perform Delete operation&quot;),
			@ApiResponse(code = 404, message = &quot;FailurePoint object not found in ES for given FailurePoint ID&quot;),
			@ApiResponse(code = 400, message = &quot;Input Request object is not valid&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/{id}&quot;, method = RequestMethod.DELETE, produces = &quot;application/json&quot;)
	public ResponseEntity&lt;Object&gt; deleteFailurePoint(@PathVariable(&quot;id&quot;) String id) {
<span class="fc" id="L321">		logger.debug(&quot;Deleting FailurePoint with id : %s &quot;, id);</span>

<span class="fc" id="L323">		FailurePoint failurePoint = failurePointService.findOne(id);</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">		if (failurePoint == null) {</span>
<span class="fc" id="L325">			final String error = &quot;Unable to delete. FailurePoint not found with id &quot; + id;</span>
<span class="fc" id="L326">			logger.debug(error);</span>
<span class="fc" id="L327">			final MessageWrapper apiError = new MessageWrapper(HttpStatus.NOT_FOUND, error, error);</span>
<span class="fc" id="L328">			return new ResponseEntity&lt;&gt;(apiError, new HttpHeaders(), apiError.getStatus());</span>
		}
<span class="fc" id="L330">		failurePointService.delete(failurePoint);</span>
<span class="fc" id="L331">		return new ResponseEntity&lt;&gt;(HttpStatus.OK);</span>
	}

	/**
	 * This API deletes All FailurePoint
	 * 
	 * @return
	 */
	@ApiOperation(value = &quot;This API deletes all FailurePoint Objects from Elastic Search&quot;, response = ResponseEntity.class)
	@ApiResponses(value = { @ApiResponse(code = 200, message = &quot;All FailurePoint object successfully deleted from ES&quot;),
			@ApiResponse(code = 401, message = &quot;User is not authorized to perform Delete operation&quot;),
			@ApiResponse(code = 400, message = &quot;Input Request object is not valid&quot;) })
	@RequestMapping(value = &quot;/api/failurepoints/&quot;, method = RequestMethod.DELETE, produces = &quot;application/json&quot;)
	public ResponseEntity&lt;Object&gt; deleteAllFailurePoints() {
<span class="fc" id="L345">		logger.debug(&quot;Deleting All FailurePoints&quot;);</span>
<span class="fc" id="L346">		failurePointService.deleteAllFailurePoint();</span>
<span class="fc" id="L347">		return new ResponseEntity&lt;&gt;(HttpStatus.OK);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>